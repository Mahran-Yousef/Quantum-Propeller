(ns propeller.pushstate
  (:use [propeller util])
  (:require [libpython-clj.python :refer [py. py.. py.-] :as py]))

(py/initialize! :python-executable "C:\\Users\\user\\anaconda3\\python.exe"
                :library-path "C:\\Users\\user\\anaconda3\\python37.dll"
                :windows-anaconda-activate-bat "C:\\Users\\user\\anaconda3\\Scripts\\activate.bat")

(require '[libpython-clj.require :refer [require-python]])

(require-python 'qiskit)

(def example-push-state
  {:exec    '()
   :integer '(1 2 3 4 5 6 7)
   :string  '("abc")
   :input   {:in1 4}})

(def empty-push-state
  {:exec    '()
   :integer '()
   :string  '()
   :boolean '()
   :input   {}})
   ;:circuit (qiskit/QuantumCircuit 2 2)})

(defn push-to-stack
  "Pushes item onto stack in state"
  [state stack item]
  (update state stack conj item))

(defn pop-stack
  "Removes top item of stack."
  [state stack]
  (update state stack rest))

(defn peek-stack
  "Returns top item on a stack."
  [state stack]
  (if (empty? (get state stack))
    :no-stack-item
    (first (get state stack))))

(defn empty-stack?
  "Returns true if the stack is empty."
  [state stack]
  (empty? (get state stack)))

(defn get-args-from-stacks
  "Takes a state and a list of stacks to take args from. If there are enough args
  on each of the desired stacks, returns a map of the form {:state :args}, where
  :state is the new state and :args is a list of args from the stacks. If there
  aren't enough args on the stacks, returns :not-enough-args."
  [state stacks]
  (loop [state state
         stacks (reverse stacks)
         args '()]
    (if (empty? stacks)
      {:state state :args args}
      (let [stack (first stacks)]
        (if (empty-stack? state stack)
          :not-enough-args
          (recur (pop-stack state stack)
                 (rest stacks)
                 (conj args (peek-stack state stack))))))))